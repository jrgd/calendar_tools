#!/bin/bash

# calendr - Display calendar events grouped by date
# Shows today and tomorrow, or Friday + weekend + Monday if it's Friday,
# or Saturday + Sunday + Monday if it's Saturday

CAL_FILE="$(dirname "$0")/calendar"

# Check for options
COUNT_ONLY=false
WAYBAR_JSON=false
WEEK_MODE=false
NEXT_WEEK_MODE=false
SHOW_HELP=false

case "$1" in
    --count)
        COUNT_ONLY=true
        ;;
    --waybar-json)
        WAYBAR_JSON=true
        ;;
    --week)
        WEEK_MODE=true
        ;;
    --nextweek)
        NEXT_WEEK_MODE=true
        ;;
    --help)
        SHOW_HELP=true
        ;;
esac

# Get current date info
TODAY=$(date +%Y-%m-%d)
TODAY_DAY=$(date +%d)
TODAY_MONTH=$(date +%b)
TODAY_DOW=$(date +%u)  # 1=Monday, 7=Sunday

# Function to show help
show_help() {
    cat << EOF
calendr - Display calendar events grouped by date

USAGE:
    calendr [OPTION]

OPTIONS:
    (no option)    Show today and tomorrow (or Friday+weekend+Monday if Friday,
                   or Saturday+Sunday+Monday if Saturday)
    --count       Display only the number of events
    --week        Display current week (Monday to Sunday)
    --nextweek    Display next week (Monday to Sunday)
    --waybar-json Output JSON format for waybar with text (count) and tooltip
    --help        Show this help message

EXAMPLES:
    calendr                    # Show upcoming events
    calendr --count            # Show event count
    calendr --week             # Show current week
    calendr --nextweek         # Show next week
    calendr --waybar-json      # JSON output for waybar
EOF
}

# Function to normalize date string (remove leading zero from day)
normalize_date() {
    echo "$1" | sed 's/ 0\([1-9]\) / \1 /' | sed 's/ 00 / 0 /'
}

# Function to get Monday of a given week (0 = current week, 1 = next week)
get_week_monday() {
    local week_offset=$1
    local current_dow=$(date +%u)  # 1=Monday, 7=Sunday
    local days_back=$((current_dow - 1))  # Days to go back to get to Monday
    local days_forward=$((week_offset * 7))  # Days to add for next week
    
    # Calculate Monday: go back to Monday, then add week offset
    date -d "$TODAY -${days_back} days +${days_forward} days" "+%Y-%m-%d" 2>/dev/null || \
    date -v-${days_back}d -v+${days_forward}d "+%Y-%m-%d" 2>/dev/null || \
    echo "$TODAY"
}

# Show help if requested
if [[ "$SHOW_HELP" == true ]]; then
    show_help
    exit 0
fi

# Determine which dates to show
if [[ "$WEEK_MODE" == true ]]; then
    # Current week - Monday to Sunday
    MONDAY=$(get_week_monday 0)
    TARGET_DATES=()
    TARGET_DATES_NORMALIZED=()
    for i in {0..6}; do
        date_str=$(date -d "$MONDAY +$i days" "+%b %d" 2>/dev/null || date -v+${i}d -j -f "%Y-%m-%d" "$MONDAY" "+%b %d" 2>/dev/null)
        if [[ -n "$date_str" ]]; then
            TARGET_DATES+=("$date_str")
            TARGET_DATES_NORMALIZED+=("$(normalize_date "$date_str")")
        fi
    done
elif [[ "$NEXT_WEEK_MODE" == true ]]; then
    # Next week - Monday to Sunday
    NEXT_MONDAY=$(get_week_monday 1)
    TARGET_DATES=()
    TARGET_DATES_NORMALIZED=()
    for i in {0..6}; do
        date_str=$(date -d "$NEXT_MONDAY +$i days" "+%b %d" 2>/dev/null || date -v+${i}d -j -f "%Y-%m-%d" "$NEXT_MONDAY" "+%b %d" 2>/dev/null)
        if [[ -n "$date_str" ]]; then
            TARGET_DATES+=("$date_str")
            TARGET_DATES_NORMALIZED+=("$(normalize_date "$date_str")")
        fi
    done
elif [[ $TODAY_DOW -eq 5 ]]; then
    # Friday - show Friday, Saturday, Sunday, Monday (4 days)
    TARGET_DATES=()
    TARGET_DATES_NORMALIZED=()
    for i in {0..3}; do
        date_str=$(date -d "$TODAY +$i days" "+%b %d" 2>/dev/null || date -v+${i}d "+%b %d" 2>/dev/null)
        if [[ -n "$date_str" ]]; then
            TARGET_DATES+=("$date_str")
            TARGET_DATES_NORMALIZED+=("$(normalize_date "$date_str")")
        fi
    done
elif [[ $TODAY_DOW -eq 6 ]]; then
    # Saturday - show Saturday, Sunday, Monday (3 days)
    TARGET_DATES=()
    TARGET_DATES_NORMALIZED=()
    for i in {0..2}; do
        date_str=$(date -d "$TODAY +$i days" "+%b %d" 2>/dev/null || date -v+${i}d "+%b %d" 2>/dev/null)
        if [[ -n "$date_str" ]]; then
            TARGET_DATES+=("$date_str")
            TARGET_DATES_NORMALIZED+=("$(normalize_date "$date_str")")
        fi
    done
else
    # Other days - show today and tomorrow (2 days)
    TARGET_DATES=()
    TARGET_DATES_NORMALIZED=()
    for i in {0..1}; do
        date_str=$(date -d "$TODAY +$i days" "+%b %d" 2>/dev/null || date -v+${i}d "+%b %d" 2>/dev/null)
        if [[ -n "$date_str" ]]; then
            TARGET_DATES+=("$date_str")
            TARGET_DATES_NORMALIZED+=("$(normalize_date "$date_str")")
        fi
    done
fi

# Check if calendar file exists
if [[ ! -f "$CAL_FILE" ]]; then
    if [[ "$COUNT_ONLY" == true ]]; then
        echo "0"
    else
        echo "Error: Calendar file not found at $CAL_FILE" >&2
    fi
    exit 1
fi

# Parse calendar file and collect events for target dates
declare -A EVENTS_BY_DATE
TOTAL_COUNT=0

while IFS=$'\t' read -r date_str event_desc || [[ -n "$date_str" ]]; do
    # Skip empty lines
    [[ -z "$date_str" ]] && continue
    
    # Normalize the date from calendar file
    normalized_cal_date=$(normalize_date "$date_str")
    
    # Check if this date is in our target dates (compare normalized versions)
    for i in "${!TARGET_DATES_NORMALIZED[@]}"; do
        if [[ "$normalized_cal_date" == "${TARGET_DATES_NORMALIZED[$i]}" ]]; then
            # Use the normalized date as key
            if [[ -z "${EVENTS_BY_DATE[$normalized_cal_date]}" ]]; then
                EVENTS_BY_DATE[$normalized_cal_date]=""
            fi
            # Append event (with newline separator)
            if [[ -n "${EVENTS_BY_DATE[$normalized_cal_date]}" ]]; then
                EVENTS_BY_DATE[$normalized_cal_date]+=$'\n'
            fi
            EVENTS_BY_DATE[$normalized_cal_date]+="$event_desc"
            TOTAL_COUNT=$((TOTAL_COUNT + 1))
            break
        fi
    done
done < "$CAL_FILE"

# Function to generate formatted output
generate_formatted_output() {
    # Output events grouped by date
    # Sort dates chronologically using the normalized target dates
    for i in "${!TARGET_DATES_NORMALIZED[@]}"; do
        normalized_date="${TARGET_DATES_NORMALIZED[$i]}"
        
        # For week mode, show all days even if they have no events
        # For other modes, only show days with events
        if [[ "$WEEK_MODE" == true ]] || [[ "$NEXT_WEEK_MODE" == true ]] || [[ -n "${EVENTS_BY_DATE[$normalized_date]}" ]]; then
            # Get full date for header (e.g., "Fri 23 Jan")
            # Parse month and day from normalized_date
            month=$(echo "$normalized_date" | awk '{print $1}')
            day=$(echo "$normalized_date" | awk '{print $2}')
            
            # Get current year
            year=$(date +%Y)
            
            # Convert month abbreviation to number for date calculation
            case "$month" in
                Jan) month_num=01 ;;
                Feb) month_num=02 ;;
                Mar) month_num=03 ;;
                Apr) month_num=04 ;;
                May) month_num=05 ;;
                Jun) month_num=06 ;;
                Jul) month_num=07 ;;
                Aug) month_num=08 ;;
                Sep) month_num=09 ;;
                Oct) month_num=10 ;;
                Nov) month_num=11 ;;
                Dec) month_num=12 ;;
                *) month_num=01 ;;
            esac
            
            # Format day with leading zero for date calculation
            day_padded="$day"
            if [[ ${#day} -eq 1 ]]; then
                day_padded="0$day"
            fi
            
            # Get day of week abbreviation
            full_date="$year-$month_num-$day_padded"
            dow=$(date -d "$full_date" "+%a" 2>/dev/null || date -j -f "%Y-%m-%d" "$full_date" "+%a" 2>/dev/null || echo "")
            
            # Format header: "Fri 23 Jan" (DOW day month, day without leading zero)
            if [[ -n "$dow" ]]; then
                echo "$dow $day $month"
            else
                echo "$day $month"
            fi
            
            # Output events for this date (already sorted by time from calendar file)
            echo "${EVENTS_BY_DATE[$normalized_date]}" | while IFS= read -r event; do
                [[ -n "$event" ]] && echo "  $event"
            done
            
            echo ""  # Empty line between dates
        fi
    done
}

# Function to escape JSON string
escape_json() {
    local str="$1"
    # Escape backslashes first
    str="${str//\\/\\\\}"
    # Escape quotes
    str="${str//\"/\\\"}"
    # Escape newlines
    str="${str//$'\n'/\\n}"
    # Escape tabs
    str="${str//$'\t'/\\t}"
    echo -n "$str"
}

# Output results
if [[ "$COUNT_ONLY" == true ]]; then
    echo "$TOTAL_COUNT"
elif [[ "$WAYBAR_JSON" == true ]]; then
    # Generate formatted output for tooltip
    TOOLTIP_OUTPUT=$(generate_formatted_output)
    # Remove trailing newline from tooltip
    TOOLTIP_OUTPUT="${TOOLTIP_OUTPUT%$'\n'}"
    
    # Escape the tooltip for JSON
    TOOLTIP_ESCAPED=$(escape_json "$TOOLTIP_OUTPUT")
    
    # Output JSON
    echo "{\"text\":\"$TOTAL_COUNT\",\"tooltip\":\"$TOOLTIP_ESCAPED\"}"
else
    # Regular output
    generate_formatted_output
fi
